# jitboy

この記事は[sysprog21/jitboy](https://github.com/sysprog21/jitboy)のREADMEの一部を翻訳したものです。

## JIT

ゲームボーイのハードウェアを従来のPC（x86-64アーキテクチャ）でエミュレーションするために、JITコンパイルエミュレーションコアを実装しました。

インタプリタ型エミュレータのように、ループ内の個々の命令をデコードして解釈するのではなく、通常はジャンプ命令で終わるブロック全体（JP,JR,CALL,RST,RET,RETI）を組み合わせて扱います。

LuaJITプロジェクトのランタイムアセンブラ`DynASM`によって、ブロックに対応するx86命令が生成され、メモリアドレスにジャンプした最初の時点でそのx86命令が実行されます。

開発時の一つの目標は、ステータスフラグをエミュレートするのではなく、ホストアーキテクチャ(x86)のステータスフラグ（carry, half-carry/adjust, zero）をエミュレート環境にそのまま使用することでした。

Z80ライクなゲームボーイのCPU LR35902と、最近のプロセッサでもほとんどサポートされているIntel 8080アーキテクチャは非常によく似ているので、ほとんどの場合、これは問題なく可能です。ただし、ゲームボーイの減算フラグはx86-64アーキテクチャに直接対応していないため、ステータスフラグの中で唯一エミュレートする必要があります。

ゲームボーイのJUMPは直接実行するのではなく、ジャンプターゲットを保存し、生成された関数をRETで終了させます。これにより、ランタイム環境では、まずジャンプ先のブロックをコンパイルし、割込み、グラフィックス、入力、DMAエミュレーションなどの他の並列タスクを実行することができます。

プログラムブロックのコンパイル時に、ブロックを抜けるポイントごとに、それまでに要したゲームボーイのクロック数を計算しておき、実行時に命令カウンタに加算します。

このカウンタにより、ゲームボーイで一定時間に発生するタイマーやVBLANKの割り込みなどのイベントを、ホストプラットフォームの高速化にもかかわらず、正確なタイミングで実行することができます。

エミュレートされたプログラムの中には、一定時間内に実行された一定数の命令に依存するルーチンがあるため、互換性の問題からホストシステムのタイマーを使用することができません。

しかし、ブロック単位の実行のため、今回のエミュレータでは、割り込みやタイマーが次のジャンプの後、数クロックパルス遅れて実行または更新されるという問題があります。

コンパイルされたプログラムブロックの実行中、ゲームボーイのレジスタセットはx86-64アーキテクチャのレジスタに直接マッピングされます。

ブロックの終了時には、ゲームボーイのレジスタセット全体、プロセッサフラグ、エミュレートされたクロックサイクル数を`gb_struct`構造体として保存する必要があります。

次の表は、翻訳されたブロックの実行中のレジスタ使用状況を示しています。ゲームボーイの16ビット命令に必要な結合レジスタAF、BC、DE、HLは、まず一時レジスタにまとめられ、命令後に書き戻されます。

| Game Boy | x86-64   | comment |
|----------|----------|---------|
| A        | r0 (rax) | accumulator |
| F        | -        | generated dynamically from the `FLAGS` register |
| B        | r1 (rcx) | |
| C        | r2 (rdx) | |
| D        | r3 (rbx) | |
| E        | r13      | |
| H        | r5 (rbp) | |
| L        | r6 (rsi) | |
| SP       | r7 (rdi) | |
| PC       | -        | not necessary |
| -        | r8       | base address of Game Boy address space |
| -        | r9       | address of strct `gb_state` |
| -        | r10      | temporary register |
| -        | r11      | temporary register |
| -        | r12      | temporary register |
| -        | r4 (rsp) | host stack pointer |

もうひとつの重要な目標は、メモリをエミュレートせずにx86のメモリをそのままゲームボーイのメモリとして使うことを可能にすることでした。

ゲームボーイのアドレス空間のアドレスを読み出すためには、ベースポインタをアドレスに加えるだけでよいのです。

読み出しはベースポインタを使えば大丈夫ですが、これは書き込みには使えません。

なぜなら，ROM内のアドレスへのライト(Write)アクセスはMBCによるバンクチェンジにつながり，またIOレジスタの中にはライトアクセス中にDMA転送やジョイパッドボタンの読み取りなどの特定の動作を引き起こすものがあるからです。

そのため，ライトアクセスは，必要な副作用をエミュレートする関数コールで置き換えられます。

ダイレクトなリード(Read)アクセスには、いくつかの重要な意味があります。

- まず読み込みのオーバーヘッドがほとんどありません。ゲームボーイと比較して、エミュレーションによる読み出しのオーバーヘッドはほとんどありません。読み込みのメモリアクセスは最も頻度の高い命令の一つであるため、大幅な効率化が図れます。
- エミュレートされたゲームボーイのアドレス空間は連続していなければなりません。ROMやRAMのバンクを変更する際には、まず`munmap`や`mmap`で対応するバンクをアドレス空間にマッピングする必要があるため、多くの追加作業が必要となります。
- ステータスレジスタは常に更新されなければいけません。TIMAタイマーや現在描画されているイメージラインを表すLYなどの特別なステータスレジスタを更新するためには、プログラムシーケンスを頻繁に中断しなければなりません。これが行われないと、キューが終了しなくなることがあります。

### 翻訳の具体例

プログラムブロックを翻訳して実行するための個々のステップは、例を挙げて説明する必要があります。

以下のリストは、ゲーム「スーパーマリオワールド」のプログラムのとあるブロックを示しています。

```
3E 02		LD A, 2
EA 00 20	LD (0x2000), A
E0 FD		LDH (0xFD), A
FA 1D DA	LD A, (0xDA1D)
FE 03		CP A, 3
20 0B		JR NZ, 0xOB
3E FF		LD A, 0xFF
EA 1D DA	LD (0xDA1D), A
CD E8 09	CALL 0x9E8
```

最初のステップでは、ブロックの最後まで命令が読み込まれます。

すべての無条件ジャンプ（`JP`,`CALL`,`RST`,`RET`,`RETI`）と`EI`がブロックを終了させるポイントになります。

命令はリンクリストに格納され、タイプ別にグループ化されます。

この命令リストには、最適化のためのさまざまなルールが適用され、ステータスレジスタの保存と復元のための命令が挿入されます。

そして、適切なx86_64アセンブラが生成されます。この例では、最適化なしで次のようなコードに変換されます。

```asm
    prologue
    mov A, 2
    write_byte 0x2000, A
    write_byte 0xfffd, A
    mov A, [aMem + 0xda1d]
    cmp A, 3
    save_cc
    restore_cc
    jz >1
    add qword state->inst_count, 17
    return 0x239
1:  mov A, 0xff
    write_byte 0xda1d, A
    dec SP
    dec SP
    and SP, 0xffff
    mov word [aMem + SP], 0x235
    add qword state->inst_count, 28
    mov byte state->return_reason, REASON_CALL
   return 0x9e8
```

この例ではわかりやすくするために、いくつかのマクロを使っています。

- `prologue`: 全部の必要なレジスタを退避して、GBのレジスタをリストアします。
- `return`: 全部のGBのレジスタを`gb_state`構造体に退避し、元のレジスタの内容をリストアします。マクロの引数は呼び出し規約で関数の結果を格納することになっているレジスタに書き込まれ、関数を`RET`で抜けます。
- `write_byte`: 関数`gb_memory_write`を呼び出します。
- `save_cc`: ステータスレジスタをスタック上に退避します。
- `restore_cc`: スタックからステータスレジスタをリストアします。

`aMem`はゲームボーイのアドレス空間のベースアドレスを格納するレジスタ`r8`を、`state`は`gb_state`のアドレスを格納するレジスタ`r9`を指定しています。

`state->inst_count`はゲームボーイの実行クロックサイクルをカウントし、`state->trap_reason`はデバッガのバックトレースを更新するためにブロックを終了する命令を指定します。ただし、現時点でデバッガはまだ実装されていません。

次のステップでは、`DynASM`を使って生成したx86アセンブリをコンパイルし、あらかじめ割り当てられたメモリ領域に書き込むように変換します。

この後、`mprotect`を使用して、関数を実行することができます。再び実行する際に高速に実行できるように、関数ポインタは開始アドレスを介してインデックスを付けて保存されます。関数が返すメモリアドレスは、次に実行されるブロックの開始アドレスとなります。

割り込みが発生した場合は、代わりにゲームボーイのスタックに置かれ、割り込みハンドラの開始アドレスにジャンプします。

ROMではなくRAM内のメモリアドレスにゲームボーイのPCがジャンプした場合、次の実行時には命令の順序が変わっていることを想定する必要があります。

そのため、RAM内のブロックは、実行後に破棄されます。

0xFF80から0xFFFEまでのブロックは例外で、この領域へのジャンプは、DMA転送時に短時間で行われる必要があります。転送の終了を待つルーチンは、通常、プログラムの実行中には変更されません。したがって、このメモリ領域への書き込みアクセスがあるまで、ブロックを一時的に保存しておくことは有意義です。

## 最適化

この記事は[Optimization](https://github.com/sysprog21/jitboy#optimization)を翻訳したものです。

命令ブロックを読み込んだ後、最適化のためのいくつかのルールが適用できます。以下ではそれらのルールについて解説していきます。

ループは、大量のジャンプによってプログラムの流れを中断することが多いため、レジスタの内容を保存・復元したり、割り込みをチェックしたりするためのオーバーヘッドが非常に大きくなります。このため、実装されている最適化機能のほとんどは、ループの検出と処理のためのものです。

ループを認識する最も簡単な方法は、現在のブロックの開始アドレスにジャンプするかどうかをチェックすることです。なぜなら、最初のループ処理の後、この開始アドレスから新しいブロックへの変換が行われるからです。

ループ本体にメモリの読み書きがなく、すべての割り込みがRETまたはRETIで返される場合、ループ全体を一気に実行することができます。この場合、割り込みがループの前、中、後のいずれで実行されるかは関係ありません。

一定のクロックサイクル数を待つ単純な待ちループは、この方法で高速化できます。実行環境に制御を委ねたり、その間に割り込みをチェックしたりすることなく、ブロックの先頭に戻ることが直接実行されます。

また、書き込みによるメモリアクセスも通常は安全に行うことができます。しかし、この場合、割り込みハンドラがループの影響を受け、追加で実行されたループの繰り返しによって誤った動作をする可能性があります。

一方、メモリアクセスの読み出しは、割り込みやタイマを待つ待ちループが終了しなくなるなど、大きなリスクを伴います。

タイマやステータスレジスタへのリードアクセスは、通常、特別な命令(`LDH A, (0xff00+a8)`や`LDH A, (0xff00+C)`)で実行されるため、最適化レベルの高いループでは、他のリード命令が許可されます。

以下のループは、長さBC、終了アドレスHLのメモリ領域に対してmemsetを実行するもので、上記の最適化により中断することなく実行することができます。

```
32		LD (HL-), A	; Set byte and decrement HL
05		DEC B
20 FC	JR NZ, 0xFC	; jump to the beginning
0D		DEC C
20 F9	JR NZ, 0xF9	; jump to the beginning
```

また、パターンマッチングを利用して、単純化できることが知られているような頻出命令列を探す最適化もあります。よく使われる次のパターンは、ディスプレイの特定の行が描画されるまで待機します。

```
F0 44		LDH A, (0x44)	; read current display line
FE ??		CP A, ??	; compare with a fixed value
20 FA		JR NZ, 0xFA	; jump to the beginning
```

代わりに、エミュレーションに対して修正したHALT命令を挿入して、割り込みの代わりに対応する表示ラインの描画を待ちます。

